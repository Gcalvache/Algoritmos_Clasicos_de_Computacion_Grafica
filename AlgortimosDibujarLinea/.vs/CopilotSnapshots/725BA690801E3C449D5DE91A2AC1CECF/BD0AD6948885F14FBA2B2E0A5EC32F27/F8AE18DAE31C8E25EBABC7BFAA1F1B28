using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace AlgortimosDibujarLinea
{
    public partial class frmMetodoCirculoPolar : Form
    {
        private bool _firstAutoSet = true;

        public frmMetodoCirculoPolar()
        {
            InitializeComponent();

            // Asociar eventos de botones
            btnCalcular.Click += BtnCalcular_Click;
            btnLimpiar.Click += BtnLimpiar_Click;
            btnSalir.Click += BtnSalir_Click;

            if (trkZoom != null)
            {
                trkZoom.Minimum = 1;
                trkZoom.Maximum = 2000;
                trkZoom.TickFrequency = 10;
                trkZoom.Value = 100;
                trkZoom.Scroll += TrkZoom_Scroll;
                lblZoom.Text = $"Zoom: {ScaleFromTrack(trkZoom.Value):0.##} px/unidad";
            }

            pcbGrafico.Image = new Bitmap(pcbGrafico.Width, pcbGrafico.Height);
        }

        private float ScaleFromTrack(int trackValue) => trackValue / 10f;
        private int TrackFromScale(float scale) => (int)Math.Max(1, Math.Round(scale * 10f));

        private void TrkZoom_Scroll(object sender, EventArgs e)
        {
            if (lblZoom != null && trkZoom != null)
                lblZoom.Text = $"Zoom: {ScaleFromTrack(trkZoom.Value):0.##} px/unidad";
            // Redibujar con el nuevo zoom
            BtnCalcular_Click(this, EventArgs.Empty);
        }

        private void BtnSalir_Click(object sender, EventArgs e)
        {
            Close();
        }

        private void BtnLimpiar_Click(object sender, EventArgs e)
        {
            txtXc.Clear();
            txtYc.Clear();
            txtR.Clear();
            if (pcbGrafico.Image != null)
            {
                using (Graphics g = Graphics.FromImage(pcbGrafico.Image)) g.Clear(pcbGrafico.BackColor);
                pcbGrafico.Invalidate();
            }

            _firstAutoSet = true;
            if (this.Controls.ContainsKey("statusStrip1") && tsslInfo != null) tsslInfo.Text = string.Empty;
        }

        // Generador de puntos en coordenadas polares
        private List<Point> GeneratePolarPoints(int xc, int yc, int r)
        {
            var points = new List<Point>();
            var seen = new HashSet<Point>();
            Action<int,int> add = (px, py) => {
                var p = new Point(px, py);
                if (seen.Add(p)) points.Add(p);
            };

            if (r < 0) return points;
            if (r == 0)
            {
                add(xc, yc);
                return points;
            }

            double dtheta = 1.0 / Math.Max(1, r);
            double limit = Math.PI / 4.0;

            for (double theta = 0.0; theta <= limit + 1e-9; theta += dtheta)
            {
                int x = (int)Math.Round(r * Math.Cos(theta));
                int y = (int)Math.Round(r * Math.Sin(theta));

                add(xc + x, yc + y);
                add(xc - x, yc + y);
                add(xc + x, yc - y);
                add(xc - x, yc - y);
                add(xc + y, yc + x);
                add(xc - y, yc + x);
                add(xc + y, yc - x);
                add(xc - y, yc - x);
            }

            // Asegurar el punto de 45 grados
            int xf = (int)Math.Round(r * Math.Cos(limit));
            int yf = (int)Math.Round(r * Math.Sin(limit));
            add(xc + xf, yc + yf);
            add(xc - xf, yc + yf);
            add(xc + xf, yc - yf);
            add(xc - xf, yc - yf);
            add(xc + yf, yc + xf);
            add(xc - yf, yc + xf);
            add(xc + yf, yc - xf);
            add(xc - yf, yc - xf);

            return points;
        }

        // Dibujado usando forma polar
        private void BtnCalcular_Click(object sender, EventArgs e)
        {
            try
            {
                int xc, yc, r;
                if (!int.TryParse(txtXc.Text, out xc) ||
                    !int.TryParse(txtYc.Text, out yc) ||
                    !int.TryParse(txtR.Text, out r))
                {
                    MessageBox.Show("Ingrese valores enteros válidos para Xc, Yc y R.", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }

                if (r < 0)
                {
                    MessageBox.Show("El radio debe ser no negativo.", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }

                var puntos = GeneratePolarPoints(xc, yc, r);

                if (puntos == null || puntos.Count == 0)
                {
                    MessageBox.Show("No hay puntos para dibujar.", "Info", MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return;
                }

                int width = pcbGrafico.Width;
                int height = pcbGrafico.Height;
                int margin = 12;

                float maxRadiusPx = Math.Min((width - margin * 2) / 2f, (height - margin * 2) / 2f);
                float autoScale = (r == 0) ? 10f : (maxRadiusPx / r);
                if (float.IsNaN(autoScale) || float.IsInfinity(autoScale) || autoScale <= 0f) autoScale = 10f;

                if (trkZoom != null)
                {
                    int suggestedMax = Math.Max(TrackFromScale(autoScale * 4f), 50);
                    suggestedMax = Math.Min(suggestedMax, 5000);
                    trkZoom.Minimum = 1;
                    trkZoom.Maximum = suggestedMax;

                    if (_firstAutoSet)
                    {
                        trkZoom.Value = Math.Min(trkZoom.Maximum, Math.Max(trkZoom.Minimum, TrackFromScale(autoScale)));
                        _firstAutoSet = false;
                    }
                    lblZoom.Text = $"Zoom: {ScaleFromTrack(trkZoom.Value):0.##} px/unidad";
                }

                float scale = (trkZoom != null) ? ScaleFromTrack(trkZoom.Value) : autoScale;
                scale = Math.Max(0.05f, scale);

                using (Graphics g = Graphics.FromImage(pcbGrafico.Image))
                {
                    g.SmoothingMode = SmoothingMode.HighQuality;
                    g.Clear(pcbGrafico.BackColor);

                    float spacing = scale;
                    if (spacing < 6f)
                    {
                        int unitsPerLine = (int)Math.Ceiling(6f / Math.Max(0.0001f, scale));
                        spacing = unitsPerLine * scale;
                    }

                    float cx = width / 2f;
                    float cy = height / 2f;

                    using (var penGrid = new Pen(Color.FromArgb(200, 230, 230, 230), 1))
                    {
                        for (float x = cx; x <= width; x += spacing) g.DrawLine(penGrid, x, 0, x, height);
                        for (float x = cx - spacing; x >= 0; x -= spacing) g.DrawLine(penGrid, x, 0, x, height);
                        for (float y = cy; y <= height; y += spacing) g.DrawLine(penGrid, 0, y, width, y);
                        for (float y = cy - spacing; y >= 0; y -= spacing) g.DrawLine(penGrid, 0, y, width, y);
                    }

                    using (var penAxis = new Pen(Color.Gray, 2))
                    {
                        g.DrawLine(penAxis, 0, cy, width, cy);
                        g.DrawLine(penAxis, cx, 0, cx, height);
                    }

                    Func<int, int, PointF> map = (x, y) => new PointF(cx + (x - xc) * scale, cy - (y - yc) * scale);

                    float pixelSize = Math.Max(1f, Math.Min(4f, scale * 0.6f));
                    using (var brushPixel = new SolidBrush(Color.FromArgb(220, 80, 80, 80)))
                    using (var penPixel = new Pen(Color.FromArgb(200, 20, 20, 20), 1))
                    {
                        var oldSmoothing = g.SmoothingMode;
                        g.SmoothingMode = SmoothingMode.None;
                        foreach (var p in puntos)
                        {
                            var sp = map(p.X, p.Y);
                            var rect = new RectangleF(sp.X - pixelSize / 2f, sp.Y - pixelSize / 2f, pixelSize, pixelSize);
                            g.FillRectangle(brushPixel, rect);
                            if (pixelSize >= 1.5f) g.DrawRectangle(penPixel, rect.X, rect.Y, rect.Width, rect.Height);
                        }
                        g.SmoothingMode = oldSmoothing;
                    }

                    using (var penCircle = new Pen(Color.FromArgb(200, 0, 120, 200), Math.Max(1f, scale * 0.08f)))
                    using (var penCenter = new Pen(Color.Red, 1))
                    {
                        float radiusPx = r * scale;
                        var centerScreen = map(xc, yc);
                        var rect = new RectangleF(centerScreen.X - radiusPx, centerScreen.Y - radiusPx, radiusPx * 2f, radiusPx * 2f);

                        g.DrawEllipse(penCircle, rect);

                        float centerMarker = Math.Max(2f, scale * 0.2f);
                        var centerRect = new RectangleF(centerScreen.X - centerMarker / 2f, centerScreen.Y - centerMarker / 2f, centerMarker, centerMarker);
                        g.FillEllipse(Brushes.Red, centerRect);
                        g.DrawEllipse(penCenter, centerRect);
                    }

                    // Se elimina la leyenda dibujada sobre el gráfico. En su lugar se actualiza la barra de estado si existe.
                    if (this.Controls.ContainsKey("statusStrip1") && tsslInfo != null)
                    {
                        tsslInfo.Text = $"Center=({xc},{yc})  R={r}  Scale={scale:0.##} px/unidad";
                    }
                }

                pcbGrafico.Invalidate();
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Ocurrió un error al dibujar el círculo: {ex.Message}", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }
    }
}
