using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace AlgortimosDibujarLinea
{
    public partial class frmMetodoLineaDda : Form
    {
        public frmMetodoLineaDda()
        {
            InitializeComponent();

            // Asociar eventos de botones
            btnCalcular.Click += BtnCalcular_Click;
            btnLimpiar.Click += BtnLimpiar_Click;
            btnSalir.Click += BtnSalir_Click;

            if (trkZoom != null)
            {
                trkZoom.Scroll += TrkZoom_Scroll;
                lblZoom.Text = $"Zoom: {trkZoom.Value} px";
            }

            // Inicializar picturebox con bitmap
            pcbGrafico.Image = new Bitmap(pcbGrafico.Width, pcbGrafico.Height);
        }

        private void TrkZoom_Scroll(object sender, EventArgs e)
        {
            if (lblZoom != null && trkZoom != null)
                lblZoom.Text = $"Zoom: {trkZoom.Value} px";

            // Redibujar si hay datos
            BtnCalcular_Click(this, EventArgs.Empty);
        }

        private void BtnSalir_Click(object sender, EventArgs e)
        {
            Close();
        }

        private void BtnLimpiar_Click(object sender, EventArgs e)
        {
            txtXi.Clear();
            txtYi.Clear();
            txtXf.Clear();
            txtYf.Clear();
            txtPendiente.Clear();

            if (pcbGrafico.Image != null)
            {
                using (Graphics g = Graphics.FromImage(pcbGrafico.Image))
                {
                    g.Clear(pcbGrafico.BackColor);
                }
                pcbGrafico.Invalidate();
            }
        }

        private void BtnCalcular_Click(object sender, EventArgs e)
        {
            int xi, yi, xf, yf;
            if (!int.TryParse(txtXi.Text, out xi) ||
                !int.TryParse(txtYi.Text, out yi) ||
                !int.TryParse(txtXf.Text, out xf) ||
                !int.TryParse(txtYf.Text, out yf))
            {
                // limpiar dibujo si no hay datos válidos
                if (pcbGrafico.Image != null)
                {
                    using (Graphics g = Graphics.FromImage(pcbGrafico.Image)) g.Clear(pcbGrafico.BackColor);
                    pcbGrafico.Invalidate();
                }
                return;
            }

            var linea = new Clinea(xi, yi, xf, yf);

            // Seleccionar algoritmo según la opción en la interfaz
            Clinea.LineAlgorithm algoritmo = Clinea.LineAlgorithm.DDA;
            if (cmbAlgoritmo != null && cmbAlgoritmo.SelectedItem != null)
            {
                var sel = cmbAlgoritmo.SelectedItem.ToString();
                if (sel == "Bresenham") algoritmo = Clinea.LineAlgorithm.Bresenham;
                else if (sel == "Punto Medio") algoritmo = Clinea.LineAlgorithm.Midpoint;
                else algoritmo = Clinea.LineAlgorithm.DDA;
            }

            var puntos = linea.Discretize(algoritmo);

            txtPendiente.Text = double.IsInfinity(linea.Pendiente) ? "∞" : linea.Pendiente.ToString("F4");

            // Dibujar los puntos en el PictureBox
            if (pcbGrafico.Image == null)
            {
                pcbGrafico.Image = new Bitmap(pcbGrafico.Width, pcbGrafico.Height);
            }

            using (Graphics g = Graphics.FromImage(pcbGrafico.Image))
            {
                // Limpiar
                g.Clear(pcbGrafico.BackColor);

                int width = pcbGrafico.Width;
                int height = pcbGrafico.Height;

                // Margen y tamaño de celda (se ajusta para que los puntos quepan)
                int margin = 20;
                int cellSize = 30; // valor por defecto

                int minX = 0, maxX = 0, minY = 0, maxY = 0;

                if (puntos != null && puntos.Count > 0)
                {
                    // conservar min/max originales
                    minX = puntos.Min(p => p.X);
                    maxX = puntos.Max(p => p.X);
                    minY = puntos.Min(p => p.Y);
                    maxY = puntos.Max(p => p.Y);

                    // tamaño basado en zoom si existe
                    if (trkZoom != null)
                    {
                        cellSize = trkZoom.Value;
                    }
                    else
                    {
                        // ajustar para que quepan
                        int neededCols = (maxX - minX + 1);
                        int neededRows = (maxY - minY + 1);

                        int availableW = Math.Max(50, width - margin * 2);
                        int availableH = Math.Max(50, height - margin * 2);

                        int candidateW = availableW / Math.Max(1, neededCols);
                        int candidateH = availableH / Math.Max(1, neededRows);

                        int candidate = Math.Min(candidateW, candidateH);
                        if (candidate >= 4)
                            cellSize = candidate;
                    }
                }

                // Limitar el tamaño de celda a un rango razonable
                cellSize = Math.Max(2, Math.Min(cellSize, 200));

                // Dibujar la grilla (origen en la esquina superior izquierda)
                using (var penGrid = new Pen(Color.LightGray, 1))
                {
                    for (int x = margin; x <= width; x += cellSize)
                        g.DrawLine(penGrid, x, 0, x, height);
                    for (int y = margin; y <= height; y += cellSize)
                        g.DrawLine(penGrid, 0, y, width, y);
                }

                // Rellenar casillas para cada punto y dibujar la línea conectando sus centros
                if (puntos != null && puntos.Count > 0)
                {
                    using (var fillBrush = new SolidBrush(Color.FromArgb(160, 120, 120, 120)))
                    using (var penLine = new Pen(Color.Black, Math.Max(1, cellSize / 8)))
                    using (var penOutline = new Pen(Color.Black, 1))
                    {
                        // Mapear en plano cartesiano: X -> columnas (incrementa a la derecha), Y -> filas invertidas (crece hacia arriba)
                        foreach (var p in puntos)
                        {
                            int col = p.X - minX;
                            int row = maxY - p.Y; // invertir Y para plano cartesiano

                            int rectX = margin + col * cellSize;
                            int rectY = margin + row * cellSize;

                            g.FillRectangle(fillBrush, rectX, rectY, cellSize, cellSize);
                            g.DrawRectangle(penOutline, rectX, rectY, cellSize, cellSize);
                        }

                        // Dibujar línea conectando centros en orden de la lista de puntos
                        for (int i = 1; i < puntos.Count; i++)
                        {
                            var p1 = puntos[i - 1];
                            var p2 = puntos[i];

                            int x1 = margin + (p1.X - minX) * cellSize + cellSize / 2;
                            int y1 = margin + (maxY - p1.Y) * cellSize + cellSize / 2;
                            int x2 = margin + (p2.X - minX) * cellSize + cellSize / 2;
                            int y2 = margin + (maxY - p2.Y) * cellSize + cellSize / 2;

                            g.DrawLine(penLine, x1, y1, x2, y2);
                        }
                    }
                }
            }

            pcbGrafico.Invalidate();
        }

        private void groupBox2_Enter(object sender, EventArgs e)
        {

        }

        private void pcbGrafico_Click(object sender, EventArgs e)
        {

        }
    }
}
