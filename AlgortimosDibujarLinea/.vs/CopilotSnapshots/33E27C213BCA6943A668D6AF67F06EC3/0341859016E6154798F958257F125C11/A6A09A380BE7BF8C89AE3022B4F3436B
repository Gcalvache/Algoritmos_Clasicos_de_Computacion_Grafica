using System;
using System.Collections.Generic;
using System.Drawing;

namespace AlgortimosDibujarLinea
{
    public class Clinea
    {
        public int Xi { get; }
        public int Yi { get; }
        public int Xf { get; }
        public int Yf { get; }
        public double Pendiente { get; private set; }

        public Clinea(int xi, int yi, int xf, int yf)
        {
            Xi = xi;
            Yi = yi;
            Xf = xf;
            Yf = yf;
        }

        public enum LineAlgorithm { DDA, Bresenham, Midpoint }

        // Backwards compatible: default to DDA
        public List<Point> Discretize()
        {
            return Discretize(LineAlgorithm.DDA);
        }

        public List<Point> Discretize(LineAlgorithm alg)
        {
            switch (alg)
            {
                case LineAlgorithm.Bresenham:
                    return DiscretizeBresenham();
                case LineAlgorithm.Midpoint:
                    return DiscretizeMidpoint();
                case LineAlgorithm.DDA:
                default:
                    return DiscretizeDDA();
            }
        }

        // Algoritmo DDA (original)
        private List<Point> DiscretizeDDA()
        {
            var points = new List<Point>();

            int dx = Xf - Xi;
            int dy = Yf - Yi;
            int steps = Math.Max(Math.Abs(dx), Math.Abs(dy));

            if (steps == 0)
            {
                points.Add(new Point(Xi, Yi));
                Pendiente = double.NaN;
                return points;
            }

            double xInc = dx / (double)steps;
            double yInc = dy / (double)steps;

            double x = Xi;
            double y = Yi;

            for (int i = 0; i <= steps; i++)
            {
                points.Add(new Point((int)Math.Round(x), (int)Math.Round(y)));
                x += xInc;
                y += yInc;
            }

            Pendiente = dx == 0 ? double.PositiveInfinity : dy / (double)dx;
            return points;
        }

        // Algoritmo de Bresenham (entero, soporte para todas las octantes)
        private List<Point> DiscretizeBresenham()
        {
            var points = new List<Point>();

            int x0 = Xi;
            int y0 = Yi;
            int x1 = Xf;
            int y1 = Yf;

            int dx = Math.Abs(x1 - x0);
            int dy = Math.Abs(y1 - y0);
            int sx = x0 < x1 ? 1 : -1;
            int sy = y0 < y1 ? 1 : -1;
            int err = dx - dy;

            while (true)
            {
                points.Add(new Point(x0, y0));
                if (x0 == x1 && y0 == y1) break;
                int e2 = err << 1; // 2*err
                if (e2 > -dy)
                {
                    err -= dy;
                    x0 += sx;
                }
                if (e2 < dx)
                {
                    err += dx;
                    y0 += sy;
                }
            }

            Pendiente = (Xf - Xi) == 0 ? double.PositiveInfinity : (Yf - Yi) / (double)(Xf - Xi);
            return points;
        }

        // Algoritmo de Punto Medio (variación para todos los octantes)
        private List<Point> DiscretizeMidpoint()
        {
            var points = new List<Point>();

            int x0 = Xi;
            int y0 = Yi;
            int x1 = Xf;
            int y1 = Yf;

            int dx = x1 - x0;
            int dy = y1 - y0;

            int dx1 = Math.Abs(dx);
            int dy1 = Math.Abs(dy);

            int sx = dx >= 0 ? 1 : -1;
            int sy = dy >= 0 ? 1 : -1;

            if (dy1 <= dx1)
            {
                // iterar sobre x
                int p = 2 * dy1 - dx1;
                int twoDy = 2 * dy1;
                int twoDyMinusDx = 2 * (dy1 - dx1);

                int x = x0;
                int y = y0;
                int xEnd = x1;

                while (true)
                {
                    points.Add(new Point(x, y));
                    if (x == xEnd) break;
                    x += sx;
                    if (p < 0)
                    {
                        p += twoDy;
                    }
                    else
                    {
                        y += sy;
                        p += twoDyMinusDx;
                    }
                }
            }
            else
            {
                // iterar sobre y
                int p = 2 * dx1 - dy1;
                int twoDx = 2 * dx1;
                int twoDxMinusDy = 2 * (dx1 - dy1);

                int x = x0;
                int y = y0;
                int yEnd = y1;

                while (true)
                {
                    points.Add(new Point(x, y));
                    if (y == yEnd) break;
                    y += sy;
                    if (p < 0)
                    {
                        p += twoDx;
                    }
                    else
                    {
                        x += sx;
                        p += twoDxMinusDy;
                    }
                }
            }

            Pendiente = (Xf - Xi) == 0 ? double.PositiveInfinity : (Yf - Yi) / (double)(Xf - Xi);
            return points;
        }
    }
}
