using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace AlgortimosDibujarLinea
{
    /// <summary>
    /// Formulario para demostrar el algoritmo Cohen-Sutherland de recorte de líneas.
    /// Este módulo proporciona una interfaz donde el usuario define dos puntos con el mouse
    /// y puede ver la línea original y la línea recortada usando el algoritmo implementado
    /// en el módulo de recorte de líneas. Se validan entradas y se maneja la presentación.
    /// </summary>
    public partial class frmMetodoCorteLineaCohen : Form
    {
        private List<Tuple<Point, Point>> lines = new List<Tuple<Point, Point>>();
        private List<Tuple<Point, Point>> clipped = new List<Tuple<Point, Point>>();
        private Point? pendingPoint = null;
        private bool isDefiningRect = false;
        private Point rectStartLogical;
        private Rectangle? clipRectLogical = null;

        public frmMetodoCorteLineaCohen()
        {
            InitializeComponent();
            btnCalcular.Click += BtnCalcular_Click;
            btnLimpiar.Click += BtnLimpiar_Click;
            btnSalir.Click += BtnSalir_Click;

            if (trkZoom != null)
            {
                trkZoom.Minimum = 1;
                trkZoom.Maximum = 2000;
                trkZoom.Value = 100;
                trkZoom.Scroll += (s, e) => { lblZoom.Text = $"Zoom: {trkZoom.Value / 10f:0.##} px/unidad"; DrawBase(); };
            }

            if (pcbGrafico.Image == null) pcbGrafico.Image = new Bitmap(pcbGrafico.Width, pcbGrafico.Height);
            pcbGrafico.MouseDown += PcbGrafico_MouseDown;
            pcbGrafico.MouseMove += PcbGrafico_MouseMove;
            pcbGrafico.MouseUp += PcbGrafico_MouseUp;

            DrawBase();
        }

        private void BtnSalir_Click(object sender, EventArgs e) => Close();

        private void BtnLimpiar_Click(object sender, EventArgs e)
        {
            lines.Clear();
            clipped.Clear();
            pendingPoint = null;
            clipRectLogical = null;
            DrawBase();
        }

        private Point ScreenToLogical(int sx, int sy, out float scale)
        {
            int width = pcbGrafico.Width, height = pcbGrafico.Height;
            scale = trkZoom.Value / 10f;
            float cx = width / 2f, cy = height / 2f;
            int lx = (int)Math.Round((sx - cx) / scale);
            int ly = (int)Math.Round((cy - sy) / scale);
            return new Point(lx, ly);
        }

        private PointF LogicalToScreenF(Point p, float scale)
        {
            int width = pcbGrafico.Width, height = pcbGrafico.Height;
            float cx = width / 2f, cy = height / 2f;
            return new PointF(cx + p.X * scale, cy - p.Y * scale);
        }

        private void PcbGrafico_MouseDown(object sender, MouseEventArgs e)
        {
            if (e.Button == MouseButtons.Left)
            {
                float scale; var lp = ScreenToLogical(e.X, e.Y, out scale);
                if (pendingPoint == null)
                {
                    pendingPoint = lp;
                }
                else
                {
                    lines.Add(Tuple.Create(pendingPoint.Value, lp));
                    pendingPoint = null;
                    DrawBase();
                }
            }
            else if (e.Button == MouseButtons.Right)
            {
                // start rectangle definition
                float s; rectStartLogical = ScreenToLogical(e.X, e.Y, out s);
                isDefiningRect = true;
                clipRectLogical = null;
            }
        }

        private void PcbGrafico_MouseMove(object sender, MouseEventArgs e)
        {
            if (isDefiningRect)
            {
                float scale; var current = ScreenToLogical(e.X, e.Y, out scale);
                int x1 = Math.Min(rectStartLogical.X, current.X);
                int x2 = Math.Max(rectStartLogical.X, current.X);
                int y1 = Math.Min(rectStartLogical.Y, current.Y);
                int y2 = Math.Max(rectStartLogical.Y, current.Y);
                clipRectLogical = new Rectangle(x1, y1, x2 - x1, y2 - y1);
                DrawBase();
            }
        }

        private void PcbGrafico_MouseUp(object sender, MouseEventArgs e)
        {
            if (e.Button == MouseButtons.Right && isDefiningRect)
            {
                isDefiningRect = false;
                // clipRectLogical already updated in MouseMove
                DrawBase();
            }
        }

        private void DrawBase()
        {
            if (pcbGrafico.Image == null) pcbGrafico.Image = new Bitmap(pcbGrafico.Width, pcbGrafico.Height);
            int width = pcbGrafico.Width, height = pcbGrafico.Height;
            float scale = trkZoom.Value / 10f;

            using (Graphics g = Graphics.FromImage(pcbGrafico.Image))
            {
                g.Clear(pcbGrafico.BackColor);
                g.SmoothingMode = SmoothingMode.HighQuality;

                // grid
                float spacing = scale < 6f ? scale * (int)Math.Ceiling(6f / Math.Max(0.0001f, scale)) : scale;
                float cx = width / 2f, cy = height / 2f;
                using (var penGrid = new Pen(Color.FromArgb(200, 230, 230, 230), 1))
                {
                    for (float x = cx; x <= width; x += spacing) g.DrawLine(penGrid, x, 0, x, height);
                    for (float x = cx - spacing; x >= 0; x -= spacing) g.DrawLine(penGrid, x, 0, x, height);
                    for (float y = cy; y <= height; y += spacing) g.DrawLine(penGrid, 0, y, width, y);
                    for (float y = cy - spacing; y >= 0; y -= spacing) g.DrawLine(penGrid, 0, y, width, y);
                }

                // axes
                using (var penAxis = new Pen(Color.Gray, 2)) { g.DrawLine(penAxis, 0, cy, width, cy); g.DrawLine(penAxis, cx, 0, cx, height); }

                // draw clip rectangle if present
                if (clipRectLogical.HasValue)
                {
                    var r = clipRectLogical.Value;
                    var p1 = LogicalToScreenF(new Point(r.Left, r.Top), scale);
                    var p2 = LogicalToScreenF(new Point(r.Right, r.Bottom), scale);
                    var rectScreen = RectangleF.FromLTRB(Math.Min(p1.X, p2.X), Math.Min(p1.Y, p2.Y), Math.Max(p1.X, p2.X), Math.Max(p1.Y, p2.Y));
                    using (var pen = new Pen(Color.Blue, 2)) { pen.DashStyle = DashStyle.Dot; g.DrawRectangle(pen, Rectangle.Round(rectScreen)); }
                }

                // draw original lines
                using (var pen = new Pen(Color.DarkGray, 2))
                {
                    foreach (var ln in lines)
                    {
                        var a = LogicalToScreenF(ln.Item1, scale);
                        var b = LogicalToScreenF(ln.Item2, scale);
                        g.DrawLine(pen, a, b);
                    }
                }

                // draw pending point marker
                if (pendingPoint.HasValue)
                {
                    var sp = LogicalToScreenF(pendingPoint.Value, scale);
                    g.FillEllipse(Brushes.Red, sp.X - 3, sp.Y - 3, 6, 6);
                }

                // draw clipped segments
                using (var pen = new Pen(Color.Red, 2))
                {
                    foreach (var ln in clipped)
                    {
                        var a = LogicalToScreenF(ln.Item1, scale);
                        var b = LogicalToScreenF(ln.Item2, scale);
                        g.DrawLine(pen, a, b);
                    }
                }
            }

            pcbGrafico.Invalidate();
        }

        private void BtnCalcular_Click(object sender, EventArgs e)
        {
            clipped.Clear();

            // determine clip rectangle in logical coords; if not defined use full canvas bounds
            Rectangle clipLogical;
            if (clipRectLogical.HasValue)
            {
                clipLogical = clipRectLogical.Value;
            }
            else
            {
                int width = pcbGrafico.Width, height = pcbGrafico.Height;
                float scale = trkZoom.Value / 10f;
                int xmin = (int)Math.Ceiling(-(width / 2f) / scale);
                int xmax = (int)Math.Floor((width / 2f) / scale);
                int ymin = (int)Math.Ceiling(-(height / 2f) / scale);
                int ymax = (int)Math.Floor((height / 2f) / scale);
                clipLogical = new Rectangle(xmin, ymin, xmax - xmin, ymax - ymin);
            }

            foreach (var ln in lines)
            {
                Point p0 = ln.Item1; Point p1 = ln.Item2;
                var cp0 = p0; var cp1 = p1;
                bool ok = CRecorteLinea.CohenSutherlandClip(ref cp0, ref cp1, new Rectangle(clipLogical.Left, clipLogical.Top, clipLogical.Width, clipLogical.Height));
                if (ok)
                {
                    clipped.Add(Tuple.Create(cp0, cp1));
                }
            }

            DrawBase();
            MessageBox.Show($"Recorte completado. Segmentos visibles: {clipped.Count} / {lines.Count}", "Info", MessageBoxButtons.OK, MessageBoxIcon.Information);
        }

        private void frmMetodoCorteLineaCohen_Load(object sender, EventArgs e)
        {
        }
    }
}
