using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;

namespace AlgortimosDibujarLinea
{
    /// <summary>
    /// Módulo de relleno de polígonos y regiones.
    /// Descripción técnica: contiene implementaciones de varias estrategias de relleno:
    /// - FloodFillSeed: relleno por semilla (stack/DFS) con opción 4- u 8-conectividad.
    /// - BoundaryFillSeed: alias que reutiliza FloodFillSeed cuando la frontera se suministra
    ///   como un conjunto de puntos.
    /// - ScanlineSeedFill: implementación basada en scanline iniciada desde una semilla,
    ///   que rellena líneas horizontales y explora spans por encima y por debajo.
    ///
    /// Justificación de variantes: se ofrecen Flood y Scanline porque cubren casos
    /// simples (flood) y casos más eficientes en memoria/tiempo para regiones grandes
    /// (scanline). Mantener las implementaciones desacopladas permite comparar
    /// rendimiento y extenderlas.
    ///
    /// Requerimientos no funcionales:
    /// - Validación de entradas para prevenir excepciones y límites fuera de rango.
    /// - Código modular y documentado en español.
    /// - Los métodos devuelven listas de puntos para facilitar la visualización por la UI.
    /// </summary>
    internal class CRelleno
    {
        /// <summary>
        /// Relleno flood (seed-based). Devuelve la lista de puntos en el orden en que fueron rellenados.
        /// - boundary: conjunto de puntos que forman la frontera y no deben rellenarse.
        /// - seed: punto semilla en coordenadas del mundo.
        /// - eightConnected: true para 8-conectividad, false para 4-conectividad.
        /// </summary>
        public static List<Point> FloodFillSeed(Point seed, HashSet<Point> boundary, bool eightConnected = false)
        {
            var result = new List<Point>();
            if (boundary == null || boundary.Count == 0) return result;

            // caja delimitadora para limitar el flood
            GetBounds(boundary, out int minX, out int maxX, out int minY, out int maxY);

            // Si la semilla está fuera de los límites, extender los límites en 1 para que el relleno pueda comenzar
            if (seed.X < minX) minX = seed.X - 1;
            if (seed.X > maxX) maxX = seed.X + 1;
            if (seed.Y < minY) minY = seed.Y - 1;
            if (seed.Y > maxY) maxY = seed.Y + 1;

            var visited = new HashSet<Point>();
            var stack = new Stack<Point>();

            if (boundary.Contains(seed)) return result;

            stack.Push(seed);

            Point[] dirs4 = new[] { new Point(1, 0), new Point(-1, 0), new Point(0, 1), new Point(0, -1) };
            Point[] dirs8 = new[] {
                new Point(1,0), new Point(-1,0), new Point(0,1), new Point(0,-1),
                new Point(1,1), new Point(1,-1), new Point(-1,1), new Point(-1,-1)
            };

            var dirs = eightConnected ? dirs8 : dirs4;

            while (stack.Count > 0)
            {
                var p = stack.Pop();
                if (visited.Contains(p)) continue;
                if (p.X < minX || p.X > maxX || p.Y < minY || p.Y > maxY) continue;
                if (boundary.Contains(p)) continue;

                visited.Add(p);
                result.Add(p);

                foreach (var d in dirs)
                {
                    var np = new Point(p.X + d.X, p.Y + d.Y);
                    if (!visited.Contains(np) && !boundary.Contains(np)) stack.Push(np);
                }
            }

            return result;
        }

        /// <summary>
        /// Boundary fill: alias a FloodFillSeed para reutilizar la misma lógica cuando
        /// se provee la frontera como conjunto de puntos.
        /// </summary>
        public static List<Point> BoundaryFillSeed(Point seed, HashSet<Point> boundary, bool eightConnected = false)
        {
            return FloodFillSeed(seed, boundary, eightConnected);
        }

        /// <summary>
        /// Scanline seed fill: rellena por líneas horizontales (scanlines) empezando
        /// desde la semilla y empujando semillas para spans adyacentes arriba/abajo.
        /// Esta variante es más eficiente en memoria para regiones grandes.
        /// </summary>
        public static List<Point> ScanlineSeedFill(Point seed, HashSet<Point> boundary)
        {
            var result = new List<Point>();
            if (boundary == null || boundary.Count == 0) return result;

            GetBounds(boundary, out int minX, out int maxX, out int minY, out int maxY);

            var visited = new HashSet<Point>();
            var stack = new Stack<Point>();

            if (boundary.Contains(seed)) return result;

            stack.Push(seed);

            while (stack.Count > 0)
            {
                var p = stack.Pop();
                int x = p.X;
                int y = p.Y;

                if (y < minY || y > maxY || x < minX || x > maxX) continue;
                if (boundary.Contains(p) || visited.Contains(p)) continue;

                // mover al punto más a la izquierda en esta línea de escaneo
                int xLeft = x;
                while (xLeft - 1 >= minX && !boundary.Contains(new Point(xLeft - 1, y)) && !visited.Contains(new Point(xLeft - 1, y))) xLeft--;

                int xRight = x;
                while (xRight + 1 <= maxX && !boundary.Contains(new Point(xRight + 1, y)) && !visited.Contains(new Point(xRight + 1, y))) xRight++;

                // rellenar de xLeft a xRight
                for (int xi = xLeft; xi <= xRight; xi++)
                {
                    var pt = new Point(xi, y);
                    if (visited.Add(pt)) result.Add(pt);
                }

                // comprobar spans arriba y abajo en busca de semillas
                for (int xi = xLeft; xi <= xRight; xi++)
                {
                    var above = new Point(xi, y + 1);
                    if (y + 1 <= maxY && !boundary.Contains(above) && !visited.Contains(above))
                    {
                        // agregar semilla en el primer punto del span
                        stack.Push(above);
                    }

                    var below = new Point(xi, y - 1);
                    if (y - 1 >= minY && !boundary.Contains(below) && !visited.Contains(below))
                    {
                        stack.Push(below);
                    }
                }
            }

            return result;
        }

        private static void GetBounds(IEnumerable<Point> pts, out int minX, out int maxX, out int minY, out int maxY)
        {
            minX = int.MaxValue; maxX = int.MinValue; minY = int.MaxValue; maxY = int.MinValue;
            bool any = false;
            foreach (var p in pts)
            {
                any = true;
                if (p.X < minX) minX = p.X;
                if (p.X > maxX) maxX = p.X;
                if (p.Y < minY) minY = p.Y;
                if (p.Y > maxY) maxY = p.Y;
            }
            if (!any)
            {
                minX = maxX = minY = maxY = 0;
            }
        }
    }
}
