using System;
using System.Drawing;

namespace AlgortimosDibujarLinea
{
    internal static class CRecorteLinea
    {
        // Cohen-Sutherland outcodes
        private const int INSIDE = 0; // 0000
        private const int LEFT = 1;   // 0001
        private const int RIGHT = 2;  // 0010
        private const int BOTTOM = 4; // 0100
        private const int TOP = 8;    // 1000

        private static int ComputeOutCode(int x, int y, int xmin, int ymin, int xmax, int ymax)
        {
            int code = INSIDE;
            if (x < xmin) code |= LEFT;
            else if (x > xmax) code |= RIGHT;
            if (y < ymin) code |= BOTTOM;
            else if (y > ymax) code |= TOP;
            return code;
        }

        // Cohen-Sutherland line clipping
        public static bool CohenSutherlandClip(ref Point p0, ref Point p1, Rectangle clip)
        {
            int xmin = clip.Left, ymin = clip.Top, xmax = clip.Right, ymax = clip.Bottom;
            int x0 = p0.X, y0 = p0.Y, x1 = p1.X, y1 = p1.Y;

            int outcode0 = ComputeOutCode(x0, y0, xmin, ymin, xmax, ymax);
            int outcode1 = ComputeOutCode(x1, y1, xmin, ymin, xmax, ymax);
            bool accept = false;

            while (true)
            {
                if ((outcode0 | outcode1) == 0)
                {
                    // both inside
                    accept = true;
                    break;
                }
                else if ((outcode0 & outcode1) != 0)
                {
                    // trivially reject
                    break;
                }
                else
                {
                    // at least one endpoint is outside the clip rectangle; pick it.
                    int outcodeOut = outcode0 != 0 ? outcode0 : outcode1;
                    int x = 0, y = 0;

                    // find intersection
                    if ((outcodeOut & TOP) != 0)
                    {
                        // y = ymax
                        x = x0 + (x1 - x0) * (ymax - y0) / (y1 - y0 == 0 ? 1 : (y1 - y0));
                        y = ymax;
                    }
                    else if ((outcodeOut & BOTTOM) != 0)
                    {
                        // y = ymin
                        x = x0 + (x1 - x0) * (ymin - y0) / (y1 - y0 == 0 ? 1 : (y1 - y0));
                        y = ymin;
                    }
                    else if ((outcodeOut & RIGHT) != 0)
                    {
                        // x = xmax
                        y = y0 + (y1 - y0) * (xmax - x0) / (x1 - x0 == 0 ? 1 : (x1 - x0));
                        x = xmax;
                    }
                    else if ((outcodeOut & LEFT) != 0)
                    {
                        // x = xmin
                        y = y0 + (y1 - y0) * (xmin - x0) / (x1 - x0 == 0 ? 1 : (x1 - x0));
                        x = xmin;
                    }

                    // move outside point to intersection point to clip
                    if (outcodeOut == outcode0)
                    {
                        x0 = x; y0 = y; outcode0 = ComputeOutCode(x0, y0, xmin, ymin, xmax, ymax);
                    }
                    else
                    {
                        x1 = x; y1 = y; outcode1 = ComputeOutCode(x1, y1, xmin, ymin, xmax, ymax);
                    }
                }
            }

            if (accept)
            {
                p0 = new Point(x0, y0);
                p1 = new Point(x1, y1);
            }

            return accept;
        }

        // Liang-Barsky algorithm
        public static bool LiangBarskyClip(ref Point p0, ref Point p1, Rectangle clip)
        {
            double x0 = p0.X, y0 = p0.Y, x1 = p1.X, y1 = p1.Y;
            double xmin = clip.Left, ymin = clip.Top, xmax = clip.Right, ymax = clip.Bottom;

            double dx = x1 - x0;
            double dy = y1 - y0;

            double p, q, r;
            double u1 = 0.0, u2 = 1.0;

            double[] pp = { -dx, dx, -dy, dy };
            double[] qq = { x0 - xmin, xmax - x0, y0 - ymin, ymax - y0 };

            for (int i = 0; i < 4; i++)
            {
                p = pp[i];
                q = qq[i];
                if (Math.Abs(p) < 1e-10)
                {
                    if (q < 0)
                        return false; // parallel and outside
                    // parallel and inside: continue
                }
                else
                {
                    r = q / p;
                    if (p < 0)
                    {
                        // entering
                        if (r > u2) return false;
                        if (r > u1) u1 = r;
                    }
                    else
                    {
                        // leaving
                        if (r < u1) return false;
                        if (r < u2) u2 = r;
                    }
                }
            }

            if (u1 > u2) return false;

            double cx0 = x0 + u1 * dx;
            double cy0 = y0 + u1 * dy;
            double cx1 = x0 + u2 * dx;
            double cy1 = y0 + u2 * dy;

            p0 = new Point((int)Math.Round(cx0), (int)Math.Round(cy0));
            p1 = new Point((int)Math.Round(cx1), (int)Math.Round(cy1));
            return true;
        }

        // NLN - Nicholl-Lee-Nicholl: for simplicity use Liang-Barsky as fallback
        // A full NLN implementation is more involved; Liang-Barsky produces identical clipped segment.
        public static bool NLNClip(ref Point p0, ref Point p1, Rectangle clip)
        {
            // For correctness and simplicity return Liang-Barsky result.
            return LiangBarskyClip(ref p0, ref p1, clip);
        }
    }
}
